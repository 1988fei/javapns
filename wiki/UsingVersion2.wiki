#summary Using javapns 2.0

= javapns 2.0=
== Requirements ==

  * Java 1.5
  * Open-source libraries:
    * [http://commons.apache.org/downloads/download_lang.cgi commons-lang-2.4.jar]
    * [http://commons.apache.org/downloads/download_io.cgi commons-io-1.4.jar]
    * [http://www.bouncycastle.org/latest_releases.html bcprov-jdk15-146.jar]
    * [http://logging.apache.org/log4j/1.2/download.html log4j-1.2.15.jar]
  * SSL certificate provided by Apple + private key, exported as a PKCS12 keystore file
  * Device Token ID  _(example: 2ed202ac08ea9033665d853a3dc8bc4c5e98f7c6cf8d55910df290567037dcc4)_
  * iPhone app


== Usage ==

*Download javapns2.0 from the Downloads page, or checkout the `javapns2` branch and build it.*

javapns 2.0 is designed so it can be plugged into existing projects and use their own data storage systems for devices and applications. However, the library includes its own basic implementations of these objects, so you can get started in no time.


===Basic===
Pushing a simple notification:
<code>
import javapns.`*`;
	
public class PushTest {

	public static void main(String`[]` args) {
	
		Push.alert("Hello World!", "keystore.p12", "keystore_password", false, "Your token");

	}
}
</code>

To push to multiple devices:
<code>
import javapns.`*`;
	
public class PushTest {

	public static void main(String`[]` args) {
		String`[]` devices = {"token 1", "token 2"};
		Push.alert("Hello World!", "keystore.p12", "keystore_password", false, devices);
	}
}
</code>


===Persisted with JPA===
  * Implement `javapns.devices.Device` as a POJO in your project
  * Implement `javapns.devices.DeviceFactory ` to hookup to your own DAO, or invoke JPA directly:
<code>
import java.util.`*`;
import javax.persistence.`*`;
import javax.persistence.criteria.`*`;
import javapns.devices.`*`;
import javapns.devices.exceptions.`*`;

public class DeviceFactoryImpl implements DeviceFactory {
	
	private EntityManager entityManager; // Your EntityManager instance

	public Device addDevice(String id, String token) throws Exception {
		Device device = new DeviceImpl(id, token); // Your implementation of Device
		entityManager.persist(device);
		return device;
	}

	public Device getDevice(String id) throws UnknownDeviceException, NullIdException {
		CriteriaBuilder qb = entityManager.getCriteriaBuilder();
		CriteriaQuery<Device> query = qb.createQuery(Device.class);
		Root<Device> device = query.from(Device.class);
		query.where(qb.equal(device.get("id"), id));
		List<Device> result = entityManager.createQuery(query).getResultList();
		return result.size() >= 1 ? result.get(0) : null;
	}

	public void removeDevice(String id) throws UnknownDeviceException, NullIdException {
		entityManager.remove(getDevice(id));
	}
}
</code>
  * Instantiate your `DeviceFactoryImpl` (can be instantiated by Spring)
  * Instantiate a `javapns.notification.PushNotificationManager` and invoke `setDeviceFactory(your DeviceFactoryImpl)` _(PushNotificationManager can be instantiated and DeviceFactoryImpl injected by Spring)_
  * Instantiate a `javapns.feedback.FeedbackServiceManager` and invoke `setDeviceFactory(your DeviceFactoryImpl)` _(FeedbackServiceManager can be instantiated and DeviceFactoryImpl injected by Spring)_
  * From your code, use the `PushNotificationManager` and `FeedbackServiceManager` _(both can be injected by Spring)_ as documented
  * You can also implement your own `AppleNotificationServer` and `AppleFeedbackServer` so that connection configuration to Apple servers is stored in JPA as well


===Debugging===
javapns uses Log4J for logging. To enable logging quickly, add the following code:
<code>
import org.apache.log4j.`*`;
</code>
and before using javapns in your code:
<code>
		try {
			BasicConfigurator.configure();
		} catch (Exception e) {
		}
</code>





===Useful notes===
 * *Production vs Sandbox*: the methods in `javapns.Push` accept a boolean parameter that tells javapns to use Apple's production servers or not.  If `true`, javapns will use the production services (`gateway.push.apple.com:2195` and `feedback.push.apple.com:2196`); otherwise it will use the sandbox services (`gateway.sandbox.push.apple.com:2195` and `feedback.sandbox.push.apple.com:2196`).
 * *Pushing to multiple devices*: when you have multiple devices to push to, make sure not to call `javapns.Push. ...()` for each and every token, as this will open and close network connections to Apple servers for each token (which Apple warns not to do).  Instead, provide an array of tokens; this will allow the library to open a connection, push your payload to all devices, and close the connection.
 * *Detecting push errors*:  invoke `javapns.Push.feedback(...)` periodically to get a list of devices you should remove from your notification list.  *Do NOT* rely on the list returned by the various push methods in `javapns.Push`, as they simply return a list of devices that the push engine processed (without knowing the actual push result).  Please see Apple's documentation on the Feedback Service to understand how push errors are reported.
 * *Device token vs Device ID or UDID*: tokens and UDIDs should not be confused...  *the library uses 64-byte tokens exclusively*, which is how Apple designed the Push Notification System.  You cannot push to a device using its device ID;  your mobile app MUST get a valid device token from Apple and use that token to push notifications to that device.  Note that the id used by javapns's DeviceFactory is a local reference only and is not related to the actual device UDID;  we recommend you use the device token as the id to make sure that all local devices have unique local identifiers.